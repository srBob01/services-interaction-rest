# Пример простого REST-взаимодействия между микросервисами

Этот проект состоит из двух микросервисов:

1. **RestServer**: Сервис, предоставляющий REST API для получения данных.
2. **RestClient**: Сервис, который обращается к RestServer через REST API и обрабатывает ответ.

Микросервисы взаимодействуют синхронно через `RestTemplate`. Это означает, что клиентский сервис (RestClient) ждёт завершения обработки запроса сервером (RestServer), прежде чем продолжить выполнение своей логики.

---

## Пример логов

При отправке запроса на клиентский эндпоинт (`http://localhost:8081/api/client`), в логах RestClient отображается:

```
INFO  --- Sending request to server at: http://localhost:8080/api/data
INFO  --- Response from server: Data from Server
INFO  --- End of interaction
```

### Что происходит в процессе:
1. **Отправка запроса**:
    - RestClient отправляет запрос на RestServer через `RestTemplate`.
    - Лог: `Sending request to server at: http://localhost:8080/api/data`.

2. **Обработка запроса сервером**:
    - RestServer симулирует задержку (2 секунды), обрабатывая запрос.
    - После обработки сервер возвращает строку `Data from Server`.

3. **Получение ответа клиентом**:
    - RestClient получает ответ от RestServer.
    - Лог: `Response from server: Data from Server`.

4. **Завершение взаимодействия**:
    - После получения ответа клиент завершает выполнение своей логики.
    - Лог: `End of interaction`.

---

## Для чего может использоваться этот подход?

### Преимущества:
1. **Простота реализации**: Синхронные вызовы легко понять, отладить и поддерживать.
2. **Прогнозируемость выполнения**: Порядок выполнения строго последовательный (запрос → ответ → завершение).
3. **Подходит для небольших сервисов**: Особенно для систем, где задержки минимальны и высокая доступность сервера гарантирована.

### Примеры использования:
- CRUD-операции: Получение, обновление, удаление данных.
- Взаимодействие с REST API других сервисов (например, запросы к внешнему API).
- Системы, где важен немедленный результат (например, проверка пользователя или данных в реальном времени).

### Недостатки:
1. **Блокировка потока**: Клиентский поток простаивает, пока ждёт ответа, что снижает эффективность при высоких задержках.
2. **Зависимость от доступности сервера**: Если сервер недоступен, клиент не сможет продолжить выполнение.
3. **Потенциальные проблемы с масштабируемостью**: В высоконагруженных системах синхронные вызовы могут стать узким местом из-за необходимости ждать завершения каждого запроса.